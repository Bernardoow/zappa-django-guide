{
    "docs": [
        {
            "location": "/", 
            "text": "Guide to using Django with Zappa\n\n\nThis repo exists to document the process of getting a standard Django project running live in AWS Lambda using the \n\nzappa project\n.  We will explore various configurations in a building-block fashion in the hopes that folks can leverage only the relevant parts for their needs.\n\n\nSetup your Environment\n\n\nIt is important to read this section in order to establish your working environment: \nSetup your Environment\n\n\nWalkthroughs\n\n\nCore Django Setup\n\n\nThis section documents setting up a Django project with only core Python functionality responding to HTTP calls.  The value of this core walkthrough could be to power an API driven compute engine or a event-driven data processing tool without the need to provide a UI.\n\n\nSupport for Static Files\n\n\nGenerally if you'd like to use your Django project to present a User Interface (UI) then you'll need to display Images and CSS and serve Javascript files.  These are known as static files and to deliver them using Zappa is unlike the traditional method of hosting the static files on a Linux or Windows box.  This walkthrough documents one way of hosting the files on AWS S3.", 
            "title": "Home"
        }, 
        {
            "location": "/#guide-to-using-django-with-zappa", 
            "text": "This repo exists to document the process of getting a standard Django project running live in AWS Lambda using the  zappa project .  We will explore various configurations in a building-block fashion in the hopes that folks can leverage only the relevant parts for their needs.", 
            "title": "Guide to using Django with Zappa"
        }, 
        {
            "location": "/#setup-your-environment", 
            "text": "It is important to read this section in order to establish your working environment:  Setup your Environment", 
            "title": "Setup your Environment"
        }, 
        {
            "location": "/#walkthroughs", 
            "text": "", 
            "title": "Walkthroughs"
        }, 
        {
            "location": "/#core-django-setup", 
            "text": "This section documents setting up a Django project with only core Python functionality responding to HTTP calls.  The value of this core walkthrough could be to power an API driven compute engine or a event-driven data processing tool without the need to provide a UI.", 
            "title": "Core Django Setup"
        }, 
        {
            "location": "/#support-for-static-files", 
            "text": "Generally if you'd like to use your Django project to present a User Interface (UI) then you'll need to display Images and CSS and serve Javascript files.  These are known as static files and to deliver them using Zappa is unlike the traditional method of hosting the static files on a Linux or Windows box.  This walkthrough documents one way of hosting the files on AWS S3.", 
            "title": "Support for Static Files"
        }, 
        {
            "location": "/setup/", 
            "text": "Setup your Environment\n\n\nThis section provides guidance to set up a zappa working environment.\n\n\nWhy do I need a working environment?\n\n\nWhile the ultimate goal is to have your Django application hosted in a cloud-based serverless environment, a working environment is needed to:\n\n\n\n\nCollect the required packages\n\n\nBuild a lambda compatible deployment\n\n\nUpload the deployment \n\n\nCoordinate the various AWS services to enable the cloud-based environment\n\n\n\n\nIn addition, a working environment assists with development and testing.  The caveat is that this working environment will not match exactly the cloud-based deployment. However, the goal is to get a reasonablly close approximation while still balancing ease of use.\n\n\nBaseline packages\n\n\nTo ensure baseline expectations are set, all environments will assume the following criteria:\n\n\n\n\nPython 2.7 (due to \nAWS lambda only supporting 2.7\n) \n\n\nDjango 1.10\n\n\nLatest version of \nzappa\n\n\n\n\nIn addition, zappa \nrequires\n a virtual environment in which to function.  So all approaches below include a virtual environment.  \n\n\nWhy not Python 3?\n\n\nWhile the Python community is rapidly moving to python 3, currently \nAWS lamdba supports only python 2.7\n\n\nApproach #1 - Local Machine\n\n\nYou can easily set up your working environment on your local machine. For simple projects, this is very easy to manage and maintain.  All you need is Python 2.7, pip, and virtualenv installed.  This works for Windows, MacOS, and Linux machines.  \n\n\nHere we setup a working environment named 'zappatest'\n\n\nmkdir zappatest\ncd zappatest\nvirtualenv ve\nsource ve/bin/activate\npip install django zappa\n\n\nAnd you are done.  \n\n\nCautions\n\n\nWhile this approach is easy to get up and running, the challenge comes along when you require more advanced python packages.  \n\n\nFor example, once you start connecting to databases, you will need to compile packages such as 'psycopg2' for PostGresSQL.  You should consider the implications of installing needed libraries on your local machine.\n\n\nApproach #2 - Docker with zappa\n\n\nSometimes leveraging Docker to create an isolated working environment is a good idea.  It takes more work to setup initially, but once you have the foundations, it is quite easy to create multiple working environments and it is easier to share those same environments with other folks on your team.  \n\n\nMost of this information is taken from the \ncurrent zappa docker project\n.  Be sure to check that repo for current updates.\n\n\nInital Setup\n\n\nThese steps need to be performed once\n\n\n\n\nInstall Docker\n\n\nPull the zappa docker image from Docker github\n\ndocker pull danielwhatmuff/zappa\n\n\n\n\n\nCreate a shortcut that allows AWS credentials to pass through to the docker container\n\n\n\n\n\n\nIf you use \nenvironment variables for AWS Credentials\n then use:\n\nalias zappashell='docker run -ti -e AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY -e AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID -e AWS_DEFAULT_REGION=$AWS_DEFAULT_REGION -v $(pwd):/var/task  --rm danielwhatmuff/zappa bash'\nalias zappashell \n ~/.bash_profile\n\n\nBe sure to define the \n$AWS_DEFAULT_REGION\n environment variable\n\n\n\n\n\n\nIf you use a \ncredentials file for AWS Credentials\n then use:\n\nalias zappashell='docker run -ti -e AWS_PROFILE=$AWS_PROFILE -v $(pwd):/var/task -v ~/.aws/:/root/.aws  --rm danielwhatmuff/zappa bash'\nalias zappashell \n ~/.bash_profile\n\n\nNote that you must either define the \n$AWS_PROFILE\n environment variable or edit the alias above to be hardcoded to a specific profile.  Example of hardcoding the alias:\n\nalias zappashell='docker run -ti -e AWS_PROFILE=zappa -v $(pwd):/var/task -v ~/.aws/:/root/.aws  --rm danielwhatmuff/zappa bash'\nalias zappashell \n ~/.bash_profile\n\n\n\n\n\n\n\n\n\n\n\nUsage on a Project\n\n\nOnce the steps above are complete, then it is very easy to start a working environment.\n\n\nFirst time Project setup\n\n\nYou will need to install any python dependencies and/or system libraries.  To fire up the docker container use:\n\n\n$ cd /your_zappa_project\n$ zappashell\nzappa\n\n\n\n\n\nNext, create the \nrequired\n virtual environment, activate it, and install needed dependencies\n\n\nzappa\n virtualenv ve\nzappa\n source ve/bin/activate \n(ve)zappa\n pip install -r requirements.txt\n\n\n\n\nSince the virtual environment is contained in the current directory, and the current directory is mapped to your local machine, any changes you make will be persisted between Docker container instances.  \n\n\nFinally, I recommend upgrading to the latest zappa project since it changes frequently\n\n(ve)zappa\n pip install --upgrade zappa\n\n\n\nAt this point, you are ready to start using zappa.  Once you are finished, you can simply exit the container.\n\n\nEach time using the Project\n\n\nSubsequent times you'd like to use the project, merely fire up the container:\n\n$ cd /your_zappa_project\n$ zappashell\nzappa\n source ve/bin/activate\n(ve)zappa\n \n\n\n\nChanges to the Docker Image\n\n\nOnce at the zappashell prompt you can install any needed libraries.  But if you depend on libraries that are installed in the system (essentially anything out of the current directory and virtual environment), they will be lost when the container exits.\n\n\nThe solution is to make your own Docker Image.  Full directions of creating a Docker Image is beyond the scope of this document, but essentially there are a few steps\n\n\nCreate a Dockerfile\n\n\nIn the local directory create a Dockerfile (note that only the 'D' is capitalized)\n\n\nFROM danielwhatmuff/zappa\n\nRUN yum -y install postgresql-devel\n\nCMD [\nzappa\n]\n\n\n\n\nBuild the Docker Image\n\n\nIn the same directory as the Dockerfile\n\n\ndocker build -t myzappa .\n\n\n\n\nUpdate your zappashell alias\n\n\nTo make sure it points to your new image.  Essentially replace \ndanielwhatmuff/zappa\n with \nmyzappa\n.  Example:\n\nalias zappashell='docker run -ti -e AWS_PROFILE=zappa -v $(pwd):/var/task -v ~/.aws/:/root/.aws  --rm myzappa bash'\nalias zappashell \n ~/.bash_profile", 
            "title": "Setup your Environment"
        }, 
        {
            "location": "/setup/#setup-your-environment", 
            "text": "This section provides guidance to set up a zappa working environment.", 
            "title": "Setup your Environment"
        }, 
        {
            "location": "/setup/#why-do-i-need-a-working-environment", 
            "text": "While the ultimate goal is to have your Django application hosted in a cloud-based serverless environment, a working environment is needed to:   Collect the required packages  Build a lambda compatible deployment  Upload the deployment   Coordinate the various AWS services to enable the cloud-based environment   In addition, a working environment assists with development and testing.  The caveat is that this working environment will not match exactly the cloud-based deployment. However, the goal is to get a reasonablly close approximation while still balancing ease of use.", 
            "title": "Why do I need a working environment?"
        }, 
        {
            "location": "/setup/#baseline-packages", 
            "text": "To ensure baseline expectations are set, all environments will assume the following criteria:   Python 2.7 (due to  AWS lambda only supporting 2.7 )   Django 1.10  Latest version of  zappa   In addition, zappa  requires  a virtual environment in which to function.  So all approaches below include a virtual environment.", 
            "title": "Baseline packages"
        }, 
        {
            "location": "/setup/#why-not-python-3", 
            "text": "While the Python community is rapidly moving to python 3, currently  AWS lamdba supports only python 2.7", 
            "title": "Why not Python 3?"
        }, 
        {
            "location": "/setup/#approach-1-local-machine", 
            "text": "You can easily set up your working environment on your local machine. For simple projects, this is very easy to manage and maintain.  All you need is Python 2.7, pip, and virtualenv installed.  This works for Windows, MacOS, and Linux machines.    Here we setup a working environment named 'zappatest'  mkdir zappatest\ncd zappatest\nvirtualenv ve\nsource ve/bin/activate\npip install django zappa \nAnd you are done.", 
            "title": "Approach #1 - Local Machine"
        }, 
        {
            "location": "/setup/#cautions", 
            "text": "While this approach is easy to get up and running, the challenge comes along when you require more advanced python packages.    For example, once you start connecting to databases, you will need to compile packages such as 'psycopg2' for PostGresSQL.  You should consider the implications of installing needed libraries on your local machine.", 
            "title": "Cautions"
        }, 
        {
            "location": "/setup/#approach-2-docker-with-zappa", 
            "text": "Sometimes leveraging Docker to create an isolated working environment is a good idea.  It takes more work to setup initially, but once you have the foundations, it is quite easy to create multiple working environments and it is easier to share those same environments with other folks on your team.    Most of this information is taken from the  current zappa docker project .  Be sure to check that repo for current updates.", 
            "title": "Approach #2 - Docker with zappa"
        }, 
        {
            "location": "/setup/#inital-setup", 
            "text": "These steps need to be performed once   Install Docker  Pull the zappa docker image from Docker github docker pull danielwhatmuff/zappa   Create a shortcut that allows AWS credentials to pass through to the docker container    If you use  environment variables for AWS Credentials  then use: alias zappashell='docker run -ti -e AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY -e AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID -e AWS_DEFAULT_REGION=$AWS_DEFAULT_REGION -v $(pwd):/var/task  --rm danielwhatmuff/zappa bash'\nalias zappashell   ~/.bash_profile \nBe sure to define the  $AWS_DEFAULT_REGION  environment variable    If you use a  credentials file for AWS Credentials  then use: alias zappashell='docker run -ti -e AWS_PROFILE=$AWS_PROFILE -v $(pwd):/var/task -v ~/.aws/:/root/.aws  --rm danielwhatmuff/zappa bash'\nalias zappashell   ~/.bash_profile \nNote that you must either define the  $AWS_PROFILE  environment variable or edit the alias above to be hardcoded to a specific profile.  Example of hardcoding the alias: alias zappashell='docker run -ti -e AWS_PROFILE=zappa -v $(pwd):/var/task -v ~/.aws/:/root/.aws  --rm danielwhatmuff/zappa bash'\nalias zappashell   ~/.bash_profile", 
            "title": "Inital Setup"
        }, 
        {
            "location": "/setup/#usage-on-a-project", 
            "text": "Once the steps above are complete, then it is very easy to start a working environment.", 
            "title": "Usage on a Project"
        }, 
        {
            "location": "/setup/#first-time-project-setup", 
            "text": "You will need to install any python dependencies and/or system libraries.  To fire up the docker container use:  $ cd /your_zappa_project\n$ zappashell\nzappa   Next, create the  required  virtual environment, activate it, and install needed dependencies  zappa  virtualenv ve\nzappa  source ve/bin/activate \n(ve)zappa  pip install -r requirements.txt  Since the virtual environment is contained in the current directory, and the current directory is mapped to your local machine, any changes you make will be persisted between Docker container instances.    Finally, I recommend upgrading to the latest zappa project since it changes frequently (ve)zappa  pip install --upgrade zappa  At this point, you are ready to start using zappa.  Once you are finished, you can simply exit the container.", 
            "title": "First time Project setup"
        }, 
        {
            "location": "/setup/#each-time-using-the-project", 
            "text": "Subsequent times you'd like to use the project, merely fire up the container: $ cd /your_zappa_project\n$ zappashell\nzappa  source ve/bin/activate\n(ve)zappa", 
            "title": "Each time using the Project"
        }, 
        {
            "location": "/setup/#changes-to-the-docker-image", 
            "text": "Once at the zappashell prompt you can install any needed libraries.  But if you depend on libraries that are installed in the system (essentially anything out of the current directory and virtual environment), they will be lost when the container exits.  The solution is to make your own Docker Image.  Full directions of creating a Docker Image is beyond the scope of this document, but essentially there are a few steps", 
            "title": "Changes to the Docker Image"
        }, 
        {
            "location": "/setup/#create-a-dockerfile", 
            "text": "In the local directory create a Dockerfile (note that only the 'D' is capitalized)  FROM danielwhatmuff/zappa\n\nRUN yum -y install postgresql-devel\n\nCMD [ zappa ]", 
            "title": "Create a Dockerfile"
        }, 
        {
            "location": "/setup/#build-the-docker-image", 
            "text": "In the same directory as the Dockerfile  docker build -t myzappa .", 
            "title": "Build the Docker Image"
        }, 
        {
            "location": "/setup/#update-your-zappashell-alias", 
            "text": "To make sure it points to your new image.  Essentially replace  danielwhatmuff/zappa  with  myzappa .  Example: alias zappashell='docker run -ti -e AWS_PROFILE=zappa -v $(pwd):/var/task -v ~/.aws/:/root/.aws  --rm myzappa bash'\nalias zappashell   ~/.bash_profile", 
            "title": "Update your zappashell alias"
        }, 
        {
            "location": "/walk_core/", 
            "text": "Core Django Setup\n\n\nThis section documents setting up a Django project with only core Python functionality responding to HTTP calls.  The value of this core walkthrough could be to power an API driven compute engine or a event-driven data processing tool without the need to provide a UI.\n\n\nExpectations and Goals\n\n\nAfter going through this section the following will work:\n\n\n\n\nURL Routes in your Django projects\n\n\nViews can produce html / json / data output\n\n\nManagement Commands\n\n\n\n\nWhat will not work (yet - see other walkthroughs for this functionality)\n\n\n\n\nStatic Files will not be served (More on that \nhere\n)\n\n\nThere is no database connection available (not even SQLite)\n\n\nNo HTTPS support\n\n\n\n\nSetup AWS Account Credentials\n\n\nMake sure you setup access to your AWS account from your local command line.  See: \nSetup Local Account Credentials\n\n\nCreate local environment\n\n\nSee \nSetup your Environment\n\n\nCreate very basic Django project\n\n\nFor the purposes of this walkthrough we are taking the most basic Django project.  From within your project working directory type the following.  We are creating a fictional Django project called 'frankie'\n\n\ndjango-admin startproject frankie .\n\n\n\n\nTesting the basic Django project\n\n\nAt this point if you run \n\npython manage.py runserver\n\n\n\nAnd visit http://127.0.0.1:8000 with your browser you should see the standard Django 'It Worked!' page\n\n\nNow quit the server using Control-C.  You should be back at the console prompt\n\n\nSetup Zappa\n\n\nzappa init\n\n\nYou will encounter a series of prompts:\n\n\n\n\nName of environment - just accept the default 'dev'\n\n\nS3 bucket for deployments.  Use the value of the S3 bucket you created above.  If you follow the walkthrough then use \nzappatest-code\n\n\nZappa should automatically find the correct settings file so accept the default\n\n\nSay 'no' to deploying globally\n\n\nIf everything looks ok, then accept the info\n\n\n\n\nHere's a transcript of what you should see:\n\n\n(ve) $ zappa init\n\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2557\n\u255a\u2550\u2550\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n  \u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\n \u2588\u2588\u2588\u2554\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551     \u2588\u2588\u2551  \u2588\u2588\u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u255d\n\nWelcome to Zappa!\n\nZappa is a system for running server-less Python web applications on AWS Lambda and AWS API Gateway.\nThis `init` command will help you create and configure your new Zappa deployment.\nLet's get started!\n\nYour Zappa configuration can support multiple production environments, like 'dev', 'staging', and 'production'.\nWhat do you want to call this environment (default 'dev'):\n\nYour Zappa deployments will need to be uploaded to a private S3 bucket.\nIf you don't have a bucket yet, we'll create one for you too.\nWhat do you want call your bucket? (default 'zappa-v20ssav8g'): zappatest-code\n\nIt looks like this is a Django application!\nWhat is the module path to your projects's Django settings?\nWe discovered: frankie.settings\nWhere are your project's settings? (default 'frankie.settings'):\n\nYou can optionally deploy to all available regions in order to provide fast global service.\nIf you are using Zappa for the first time, you probably don't want to do this!\nWould you like to deploy this application to globally? (default 'n') [y/n/(p)rimary]: n\n\nOkay, here's your zappa_settings.js:\n\n{\n    \ndev\n: {\n        \ndjango_settings\n: \nfrankie.settings\n,\n        \ns3_bucket\n: \nzappatest-code\n\n    }\n}\n\nDoes this look okay? (default 'y') [y/n]: y\n\nDone! Now you can deploy your Zappa application by executing:\n\n    $ zappa deploy dev\n\nAfter that, you can update your application code with:\n\n    $ zappa update dev\n\nTo learn more, check out our project page on GitHub here: https://github.com/Miserlou/Zappa\nand stop by our Slack channel here: http://bit.do/zappa\n\nEnjoy!,\n ~ Team Zappa!\n(ve) $\n\n\n\n\nTesting the Zappa Setup\n\n\nSo now if we run\n\n\nzappa deploy dev\n\n\n\n\nBut unfortunately we encounter an error: \n\n\n(ve) $ zappa deploy dev\nCalling deploy for environment dev..\nWarning! AWS Lambda may not be available in this AWS Region!\nWarning! AWS API Gateway may not be available in this AWS Region!\nOh no! An error occurred! :(\n\n==============\n\nTraceback (most recent call last):\n    [boring callback removed]\nNoRegionError: You must specify a region.\n\n==============\n\nNeed help? Found a bug? Let us know! :D\nFile bug reports on GitHub here: https://github.com/Miserlou/Zappa\nAnd join our Slack channel here: https://slack.zappa.io\nLove!,\n ~ Team Zappa!\n(ve) $\n\n\nAw man, the error \nNoRegionError: You must specify a region.\n is holding us back.  Zappa is complaining that no AWS region is specified.  So we need to specify a region.  In this walkthrough we are leveraging \nus-east-1\n which corresponds to the same region we used above for the S3 bucket.\n\n\nYou have options:\n\n\n\n\n\n\nSpecify a default region using environment variables\n\n\nAgain, the drawback here is this must be set for every console\n\n\nexport AWS_DEFAULT_REGION=us-east-1\n\n\n\n\n\n\n\n\nAdd default region in your \n~/.awd/credentials\n file\n\n\nBetter but this will affect all AWS scripts and programs on your machine.\n\n\n[default]\naws_access_key_id = your_access_key_id\naws_secret_access_key = your_secret_access_key\nregion=us-east-1\n\n\n\n\n\n\n\n\nEdit the \nzappa_settings.json\n file to have an AWS region.\n\n\nProbably best option because now the zappa configuration has minimal dependencies on external user environment.\n\n\n{\n \ndev\n: {\n     \naws_region\n: \nus-east-1\n,\n     \ndjango_settings\n: \nfrankie.settings\n,\n     \ns3_bucket\n: \nzappatest-code\n\n        } \n}\n\n\n\n\nDon't forget to put commas in the proper place - JSON is fiddly!\n\n\n\n\n\n\nDeploy your project using Zappa\n\n\nNow it's easy to do the initial deployment\n\n\nzappa deploy dev\n\n\n\n\nZappa will automatically create an AWS API gateway that will route HTTP requests to your lambda Django project.  You should see something like:\n\n\n(ve) $ zappa deploy dev\nCalling deploy for environment dev..\nDownloading and installing dependencies..\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 27/27 [00:07\n00:00,  3.91pkg/s]\nPackaging project as zip..\nUploading zappatest-dev-1482425936.zip (13.1MiB)..\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 13.8M/13.8M [00:25\n00:00, 603KB/s]\nScheduling..\nScheduled zappatest-dev-zappa-keep-warm-handler.keep_warm_callback!\nUploading zappatest-dev-template-1482425980.json (1.5KiB)..\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1.58K/1.58K [00:00\n00:00, 2.08KB/s]\nWaiting for stack zappatest-dev to create (this can take a bit)..\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4/4 [00:18\n00:00,  4.69s/res]\nDeploying API Gateway..\nDeployment complete!: https://x6kb437rh.execute-api.us-east-1.amazonaws.com/dev\n\n\n\n\nBrilliant!  We should be able to use a browser to visit the URL provided at the end of the script.\n\n\nOnce we do, however, we get:\n\n\nDisallowedHost at /\nInvalid HTTP_HOST header: 'x6kb437rh.execute-api.us-east-1.amazonaws.com'. \nYou may need to add x6kb437rh.execute-api.us-east-1.amazonaws.com' to ALLOWED_HOSTS.\n\n\n\n\nThe built-in \nDjango security settings\n are kicking in and preventing bad stuff from happening.  So we need to modify our Django settings file to accommodate the \ndefault hostname that AWS API Gateway uses\n.  Note that the AWS region is part of the hostname and thus should match your selected region.\n\n\nNow edit \nfrankie/settings.py\n and change ALLOWED_HOSTS to;\n\n\nALLOWED_HOSTS = [ '127.0.0.1', '.execute-api.us-east-1.amazonaws.com', ]\n\n\n\n\nOnce done, we can again deploy to AWS Lambda.  But this time, since we've already pushed the initial deploy, we use the \nupdate\n action on the zappa command line.\n\n\nzappa update dev\n\n\n\n\nAfter this completes, you should be able to see your Django site in action.  Note that you will actually get a Page not found (404) response.  This indicates that your Django site is functional and working.   \n\n\n\n\nHow is this functional?\n\n\nWait, what?  A 404 page is functional?  Well yes, it is.  The Lambda function is working fine.  A whole series of AWS systems are working in concert to load your python Django code and running the view.  Because we've cut to the bare minimum Django project, there is no application ready to handle the url paths.  The only thing we see is the admin application.\n\n\nSo from here we are ready to start working on views and providing data.  However, if you wish to host a website with static files and databases, continue onward to the subsequent walkthroughs.\n\n\nWhy is the URL path appended with 'dev'?\n\n\nAstute readers will notice that the url in the image shown above indeed has the root domain with the suffix of 'dev' which happens to be the name of the zappa environment.  \n\n\nAt this time, having the environment appended to the url is embedded into zappa.  However, if you place the lambda function behind a CDN such as cloudfront, this preference may be changed.", 
            "title": "Core Django Setup"
        }, 
        {
            "location": "/walk_core/#core-django-setup", 
            "text": "This section documents setting up a Django project with only core Python functionality responding to HTTP calls.  The value of this core walkthrough could be to power an API driven compute engine or a event-driven data processing tool without the need to provide a UI.", 
            "title": "Core Django Setup"
        }, 
        {
            "location": "/walk_core/#expectations-and-goals", 
            "text": "After going through this section the following will work:   URL Routes in your Django projects  Views can produce html / json / data output  Management Commands   What will not work (yet - see other walkthroughs for this functionality)   Static Files will not be served (More on that  here )  There is no database connection available (not even SQLite)  No HTTPS support", 
            "title": "Expectations and Goals"
        }, 
        {
            "location": "/walk_core/#setup-aws-account-credentials", 
            "text": "Make sure you setup access to your AWS account from your local command line.  See:  Setup Local Account Credentials", 
            "title": "Setup AWS Account Credentials"
        }, 
        {
            "location": "/walk_core/#create-local-environment", 
            "text": "See  Setup your Environment", 
            "title": "Create local environment"
        }, 
        {
            "location": "/walk_core/#create-very-basic-django-project", 
            "text": "For the purposes of this walkthrough we are taking the most basic Django project.  From within your project working directory type the following.  We are creating a fictional Django project called 'frankie'  django-admin startproject frankie .", 
            "title": "Create very basic Django project"
        }, 
        {
            "location": "/walk_core/#testing-the-basic-django-project", 
            "text": "At this point if you run  python manage.py runserver  And visit http://127.0.0.1:8000 with your browser you should see the standard Django 'It Worked!' page  Now quit the server using Control-C.  You should be back at the console prompt", 
            "title": "Testing the basic Django project"
        }, 
        {
            "location": "/walk_core/#setup-zappa", 
            "text": "zappa init \nYou will encounter a series of prompts:   Name of environment - just accept the default 'dev'  S3 bucket for deployments.  Use the value of the S3 bucket you created above.  If you follow the walkthrough then use  zappatest-code  Zappa should automatically find the correct settings file so accept the default  Say 'no' to deploying globally  If everything looks ok, then accept the info   Here's a transcript of what you should see:  (ve) $ zappa init\n\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2557\n\u255a\u2550\u2550\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n  \u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\n \u2588\u2588\u2588\u2554\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551     \u2588\u2588\u2551  \u2588\u2588\u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u255d\n\nWelcome to Zappa!\n\nZappa is a system for running server-less Python web applications on AWS Lambda and AWS API Gateway.\nThis `init` command will help you create and configure your new Zappa deployment.\nLet's get started!\n\nYour Zappa configuration can support multiple production environments, like 'dev', 'staging', and 'production'.\nWhat do you want to call this environment (default 'dev'):\n\nYour Zappa deployments will need to be uploaded to a private S3 bucket.\nIf you don't have a bucket yet, we'll create one for you too.\nWhat do you want call your bucket? (default 'zappa-v20ssav8g'): zappatest-code\n\nIt looks like this is a Django application!\nWhat is the module path to your projects's Django settings?\nWe discovered: frankie.settings\nWhere are your project's settings? (default 'frankie.settings'):\n\nYou can optionally deploy to all available regions in order to provide fast global service.\nIf you are using Zappa for the first time, you probably don't want to do this!\nWould you like to deploy this application to globally? (default 'n') [y/n/(p)rimary]: n\n\nOkay, here's your zappa_settings.js:\n\n{\n     dev : {\n         django_settings :  frankie.settings ,\n         s3_bucket :  zappatest-code \n    }\n}\n\nDoes this look okay? (default 'y') [y/n]: y\n\nDone! Now you can deploy your Zappa application by executing:\n\n    $ zappa deploy dev\n\nAfter that, you can update your application code with:\n\n    $ zappa update dev\n\nTo learn more, check out our project page on GitHub here: https://github.com/Miserlou/Zappa\nand stop by our Slack channel here: http://bit.do/zappa\n\nEnjoy!,\n ~ Team Zappa!\n(ve) $", 
            "title": "Setup Zappa"
        }, 
        {
            "location": "/walk_core/#testing-the-zappa-setup", 
            "text": "So now if we run  zappa deploy dev  But unfortunately we encounter an error:   (ve) $ zappa deploy dev\nCalling deploy for environment dev..\nWarning! AWS Lambda may not be available in this AWS Region!\nWarning! AWS API Gateway may not be available in this AWS Region!\nOh no! An error occurred! :(\n\n==============\n\nTraceback (most recent call last):\n    [boring callback removed]\nNoRegionError: You must specify a region.\n\n==============\n\nNeed help? Found a bug? Let us know! :D\nFile bug reports on GitHub here: https://github.com/Miserlou/Zappa\nAnd join our Slack channel here: https://slack.zappa.io\nLove!,\n ~ Team Zappa!\n(ve) $ \nAw man, the error  NoRegionError: You must specify a region.  is holding us back.  Zappa is complaining that no AWS region is specified.  So we need to specify a region.  In this walkthrough we are leveraging  us-east-1  which corresponds to the same region we used above for the S3 bucket.  You have options:    Specify a default region using environment variables  Again, the drawback here is this must be set for every console  export AWS_DEFAULT_REGION=us-east-1    Add default region in your  ~/.awd/credentials  file  Better but this will affect all AWS scripts and programs on your machine.  [default]\naws_access_key_id = your_access_key_id\naws_secret_access_key = your_secret_access_key\nregion=us-east-1    Edit the  zappa_settings.json  file to have an AWS region.  Probably best option because now the zappa configuration has minimal dependencies on external user environment.  {\n  dev : {\n      aws_region :  us-east-1 ,\n      django_settings :  frankie.settings ,\n      s3_bucket :  zappatest-code \n        } \n}  Don't forget to put commas in the proper place - JSON is fiddly!", 
            "title": "Testing the Zappa Setup"
        }, 
        {
            "location": "/walk_core/#deploy-your-project-using-zappa", 
            "text": "Now it's easy to do the initial deployment  zappa deploy dev  Zappa will automatically create an AWS API gateway that will route HTTP requests to your lambda Django project.  You should see something like:  (ve) $ zappa deploy dev\nCalling deploy for environment dev..\nDownloading and installing dependencies..\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 27/27 [00:07 00:00,  3.91pkg/s]\nPackaging project as zip..\nUploading zappatest-dev-1482425936.zip (13.1MiB)..\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 13.8M/13.8M [00:25 00:00, 603KB/s]\nScheduling..\nScheduled zappatest-dev-zappa-keep-warm-handler.keep_warm_callback!\nUploading zappatest-dev-template-1482425980.json (1.5KiB)..\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1.58K/1.58K [00:00 00:00, 2.08KB/s]\nWaiting for stack zappatest-dev to create (this can take a bit)..\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4/4 [00:18 00:00,  4.69s/res]\nDeploying API Gateway..\nDeployment complete!: https://x6kb437rh.execute-api.us-east-1.amazonaws.com/dev  Brilliant!  We should be able to use a browser to visit the URL provided at the end of the script.  Once we do, however, we get:  DisallowedHost at /\nInvalid HTTP_HOST header: 'x6kb437rh.execute-api.us-east-1.amazonaws.com'. \nYou may need to add x6kb437rh.execute-api.us-east-1.amazonaws.com' to ALLOWED_HOSTS.  The built-in  Django security settings  are kicking in and preventing bad stuff from happening.  So we need to modify our Django settings file to accommodate the  default hostname that AWS API Gateway uses .  Note that the AWS region is part of the hostname and thus should match your selected region.  Now edit  frankie/settings.py  and change ALLOWED_HOSTS to;  ALLOWED_HOSTS = [ '127.0.0.1', '.execute-api.us-east-1.amazonaws.com', ]  Once done, we can again deploy to AWS Lambda.  But this time, since we've already pushed the initial deploy, we use the  update  action on the zappa command line.  zappa update dev  After this completes, you should be able to see your Django site in action.  Note that you will actually get a Page not found (404) response.  This indicates that your Django site is functional and working.", 
            "title": "Deploy your project using Zappa"
        }, 
        {
            "location": "/walk_core/#how-is-this-functional", 
            "text": "Wait, what?  A 404 page is functional?  Well yes, it is.  The Lambda function is working fine.  A whole series of AWS systems are working in concert to load your python Django code and running the view.  Because we've cut to the bare minimum Django project, there is no application ready to handle the url paths.  The only thing we see is the admin application.  So from here we are ready to start working on views and providing data.  However, if you wish to host a website with static files and databases, continue onward to the subsequent walkthroughs.", 
            "title": "How is this functional?"
        }, 
        {
            "location": "/walk_core/#why-is-the-url-path-appended-with-dev", 
            "text": "Astute readers will notice that the url in the image shown above indeed has the root domain with the suffix of 'dev' which happens to be the name of the zappa environment.    At this time, having the environment appended to the url is embedded into zappa.  However, if you place the lambda function behind a CDN such as cloudfront, this preference may be changed.", 
            "title": "Why is the URL path appended with 'dev'?"
        }, 
        {
            "location": "/walk_static/", 
            "text": "Static Files Setup\n\n\nGenerally if you'd like to use your Django project to present a User Interface (UI) then you'll need to display Images and CSS and serve Javascript files.  These are known as \nstatic files\n and to deliver them using Zappa is unlike the traditional method of hosting the static files on a Linux or Windows box.  \n\n\nStatic files and Code on a Single Server\n\n\nA very common configuration you may see recommended is to have your Django project \ndeployed on a server with your static files\n.  Then the advice is to have your web server software (apache, nginx, or other) have special mechanisms to directly serve the static files.  The idea is to have the fast web server software handle delivering the static images to clients and the comparatively slow Django/python code process the more complex views and page content.  \n\n\nBecause Zappa runs in the serverless lambda environment, this approach is not feasible since you cannot configure the web server to handle various url paths differently.  Thus another approach must be taken.\n\n\nLeveraging WSGI app to serve files\n\n\nThe situation where one does not have access to the web server software configuration is more common than one may think.  Hosting in a shared environment, or on Platform as a Service (PaaS) like OpenShift may prevent full configuration of the web server to effectively serve static files.  \n\n\nThere are ways to leverage the WSGI application (Django for us) and instruct it to serve static files.  Normally, Django treats URL requests as an opportunity to run python code.  And the python code may have complex logic.  But there is a model called [WhiteNoise] (https://github.com/evansd/whitenoise).  It is an app that will minimize the python code processing to more efficiently serve static files.  Thus no external web server software configuration is required.  While perhaps not as optimal as having the web server hosting the files, this method has been used in production effectively.  \n\n\nUsing external services to serve files\n\n\nFinally, there is an option to use an \nexternal service to serve static files\n.  This is the option that is the subject of this walkthrough.\n\n\nWhile any external service that serves files over HTTP could work, the focus for us will be to leverage the AWS service of S3 and the Content Delivery Network (CDN) of CloudFront to meet our needs.  \n\n\nThe S3 service will contain our files and provide the fundamental HTTP/HTTPS service.  This alone will suffice for many recreational projects, but more professional project will want to leverage CloudFront to provide caching, faster delivery, and better protection of assets.\n\n\nNote that much of this information was pulled from \nhttps://www.caktusgroup.com/blog/2014/11/10/Using-Amazon-S3-to-store-your-Django-sites-static-and-media-files/\n\n\nUsing a CDN for the entire project\n\n\nThere are also advantages to serving the entire Django project (Lambda functions and S3 Static files) via the CloudFront CDN.  This option will not be covered in this Walkthrough.\n\n\nSetup and Prerequisites\n\n\nMake sure you understand and execute the \nCore Django Walkthrough\n first.  This Walkthrough builds upon that.\n\n\nSetup Amazon Account\n\n\nYou will need an AWS S3 bucket to host your static files.  This should not be the same as your S3 bucket used by zappa to upload your code.  The reason is that you will be making some modifications to the S3 bucket to properly use HTTP to serve files.\n\n\nCreate an S3 bucket and name it something like \nzappa-static\n.  You may name it anything you like but for the purposes of this walkthrough we will use \nzappa-static\n.  Replace all occurrences of this string with your chosen bucket name.\n\n\nConfigure CORS\n\n\nCORS\n is an HTTP standard that enables browsers to pull content from different sources on a single web page.  Because our Django Lambda views are hosted on a different URL, we must enable the CORS setting on the S3 bucket holding our static assets to allow the files to be pulled.  \n\n\nGo to your S3 bucket properties, and under \"Permissions\", click on \"Add CORS Configuration\". Paste this in:\n\n\n \nCORSConfiguration\n\n        \nCORSRule\n\n            \nAllowedOrigin\n*\n/AllowedOrigin\n\n            \nAllowedMethod\nGET\n/AllowedMethod\n\n            \nMaxAgeSeconds\n3000\n/MaxAgeSeconds\n\n            \nAllowedHeader\nAuthorization\n/AllowedHeader\n\n        \n/CORSRule\n\n    \n/CORSConfiguration\n\n\n\n\nNote that this CORS policy is very open and simple.  If you have a production site, you will probably want to narrow the scope of CORS or leverage a CDN.\n\n\nConfigure Django Project\n\n\nInstall modules\n\n\nIn order to re-use existing modules freely available, we will use the django-storages module to handle the management of files to and from AWS S3.  So first you must install it.  \nDon't forget to activate your virtual environment\n \n\n\npip install django-storages boto\n\n\n\n\nAnd thus you should take the corresponding package versions reported by \npip freeze\n into the requirements.txt file.  At the time of this writing, the additional lines would be:\n\n\n...\nboto==2.45.0\ndjango-storages==1.5.1\n...\n\n\n\n\nAdd Django-Storages to the INSTALLED_APPS in settings.py\n\n\nEdit your settings.py file to include django-storages.  Note it's just called 'storages' as an app.\n\n\nINSTALLED_APPS = (\n          ...,\n          'storages',\n     )\n\n\n\n\nConfigure Django-Storages in settings.py\n\n\nAdd these lines anywhere in your settings.py.  These values instruct Django-Storages to properly configure a basic setup for leveraging S3.  More information about these values can be found here: \nhttp://django-storages.readthedocs.io/en/latest/backends/amazon-S3.html\n\n\nAWS_STORAGE_BUCKET_NAME = 'zappa-static'\n\nAWS_S3_CUSTOM_DOMAIN = '%s.s3.amazonaws.com' % AWS_STORAGE_BUCKET_NAME\n\nSTATIC_URL = \nhttps://%s/\n % AWS_S3_CUSTOM_DOMAIN\n\nSTATICFILES_STORAGE = 'storages.backends.s3boto.S3BotoStorage'\n\n\n\n\n\nPush your static files to the cloud\n\n\nThe funny thing about zappa is that generally you have a working local environment and a working lambda environment.  In theory either location can push the static files to the cloud.  \n\n\nUsing your local environment:\n\n\npython manage.py collectstatic --noinput\n\n\n\n\nOr to instruct your zappa-powered AWS lambda environment to do it for you:\n\n\nzappa manage dev \ncollectstatic --noinput\n\n\n\n\n\nTest with the admin\n\n\nOnce you have pushed your static files to S3, you can visit the admin site for your Django project to test if it worked.  Appending /admin/ to your zappa project you can now browse to the admin site and watch the css being loaded just fine.\n\n\n\n\nNext Steps\n\n\nWell great, now you have a working Django site that processes views and can serve static files.  But you can't login because there is no database.  Continue through the walkthroughs to complete a fully functional website.\n\n\nAdditional HTTP Settings\n\n\nAs mentioned above you probably want to ensure a valid CORS policy is in place for anything resembling production.\n\n\nIn addition there are many default HTTP headers that can be served with your static files to ensure proper caching and so forth.  The example format in your settings.py file is:\n\n\n    AWS_HEADERS = {  \n        'Expires': 'Thu, 31 Dec 2099 20:00:00 GMT',\n        'Cache-Control': 'max-age=94608000',\n    }\n\n\n\n\nHelpful Links\n\n\nThese two articles were extremely helpful when writing this page:\n\n\n\n\nhttps://www.caktusgroup.com/blog/2014/11/10/Using-Amazon-S3-to-store-your-Django-sites-static-and-media-files/\n\n\nhttp://django-storages.readthedocs.io/en/latest/backends/amazon-S3.html", 
            "title": "Hosting Static Files"
        }, 
        {
            "location": "/walk_static/#static-files-setup", 
            "text": "Generally if you'd like to use your Django project to present a User Interface (UI) then you'll need to display Images and CSS and serve Javascript files.  These are known as  static files  and to deliver them using Zappa is unlike the traditional method of hosting the static files on a Linux or Windows box.", 
            "title": "Static Files Setup"
        }, 
        {
            "location": "/walk_static/#static-files-and-code-on-a-single-server", 
            "text": "A very common configuration you may see recommended is to have your Django project  deployed on a server with your static files .  Then the advice is to have your web server software (apache, nginx, or other) have special mechanisms to directly serve the static files.  The idea is to have the fast web server software handle delivering the static images to clients and the comparatively slow Django/python code process the more complex views and page content.    Because Zappa runs in the serverless lambda environment, this approach is not feasible since you cannot configure the web server to handle various url paths differently.  Thus another approach must be taken.", 
            "title": "Static files and Code on a Single Server"
        }, 
        {
            "location": "/walk_static/#leveraging-wsgi-app-to-serve-files", 
            "text": "The situation where one does not have access to the web server software configuration is more common than one may think.  Hosting in a shared environment, or on Platform as a Service (PaaS) like OpenShift may prevent full configuration of the web server to effectively serve static files.    There are ways to leverage the WSGI application (Django for us) and instruct it to serve static files.  Normally, Django treats URL requests as an opportunity to run python code.  And the python code may have complex logic.  But there is a model called [WhiteNoise] (https://github.com/evansd/whitenoise).  It is an app that will minimize the python code processing to more efficiently serve static files.  Thus no external web server software configuration is required.  While perhaps not as optimal as having the web server hosting the files, this method has been used in production effectively.", 
            "title": "Leveraging WSGI app to serve files"
        }, 
        {
            "location": "/walk_static/#using-external-services-to-serve-files", 
            "text": "Finally, there is an option to use an  external service to serve static files .  This is the option that is the subject of this walkthrough.  While any external service that serves files over HTTP could work, the focus for us will be to leverage the AWS service of S3 and the Content Delivery Network (CDN) of CloudFront to meet our needs.    The S3 service will contain our files and provide the fundamental HTTP/HTTPS service.  This alone will suffice for many recreational projects, but more professional project will want to leverage CloudFront to provide caching, faster delivery, and better protection of assets.  Note that much of this information was pulled from  https://www.caktusgroup.com/blog/2014/11/10/Using-Amazon-S3-to-store-your-Django-sites-static-and-media-files/", 
            "title": "Using external services to serve files"
        }, 
        {
            "location": "/walk_static/#using-a-cdn-for-the-entire-project", 
            "text": "There are also advantages to serving the entire Django project (Lambda functions and S3 Static files) via the CloudFront CDN.  This option will not be covered in this Walkthrough.", 
            "title": "Using a CDN for the entire project"
        }, 
        {
            "location": "/walk_static/#setup-and-prerequisites", 
            "text": "Make sure you understand and execute the  Core Django Walkthrough  first.  This Walkthrough builds upon that.", 
            "title": "Setup and Prerequisites"
        }, 
        {
            "location": "/walk_static/#setup-amazon-account", 
            "text": "You will need an AWS S3 bucket to host your static files.  This should not be the same as your S3 bucket used by zappa to upload your code.  The reason is that you will be making some modifications to the S3 bucket to properly use HTTP to serve files.  Create an S3 bucket and name it something like  zappa-static .  You may name it anything you like but for the purposes of this walkthrough we will use  zappa-static .  Replace all occurrences of this string with your chosen bucket name.", 
            "title": "Setup Amazon Account"
        }, 
        {
            "location": "/walk_static/#configure-cors", 
            "text": "CORS  is an HTTP standard that enables browsers to pull content from different sources on a single web page.  Because our Django Lambda views are hosted on a different URL, we must enable the CORS setting on the S3 bucket holding our static assets to allow the files to be pulled.    Go to your S3 bucket properties, and under \"Permissions\", click on \"Add CORS Configuration\". Paste this in:    CORSConfiguration \n         CORSRule \n             AllowedOrigin * /AllowedOrigin \n             AllowedMethod GET /AllowedMethod \n             MaxAgeSeconds 3000 /MaxAgeSeconds \n             AllowedHeader Authorization /AllowedHeader \n         /CORSRule \n     /CORSConfiguration   Note that this CORS policy is very open and simple.  If you have a production site, you will probably want to narrow the scope of CORS or leverage a CDN.", 
            "title": "Configure CORS"
        }, 
        {
            "location": "/walk_static/#configure-django-project", 
            "text": "", 
            "title": "Configure Django Project"
        }, 
        {
            "location": "/walk_static/#install-modules", 
            "text": "In order to re-use existing modules freely available, we will use the django-storages module to handle the management of files to and from AWS S3.  So first you must install it.   Don't forget to activate your virtual environment    pip install django-storages boto  And thus you should take the corresponding package versions reported by  pip freeze  into the requirements.txt file.  At the time of this writing, the additional lines would be:  ...\nboto==2.45.0\ndjango-storages==1.5.1\n...", 
            "title": "Install modules"
        }, 
        {
            "location": "/walk_static/#add-django-storages-to-the-installed_apps-in-settingspy", 
            "text": "Edit your settings.py file to include django-storages.  Note it's just called 'storages' as an app.  INSTALLED_APPS = (\n          ...,\n          'storages',\n     )", 
            "title": "Add Django-Storages to the INSTALLED_APPS in settings.py"
        }, 
        {
            "location": "/walk_static/#configure-django-storages-in-settingspy", 
            "text": "Add these lines anywhere in your settings.py.  These values instruct Django-Storages to properly configure a basic setup for leveraging S3.  More information about these values can be found here:  http://django-storages.readthedocs.io/en/latest/backends/amazon-S3.html  AWS_STORAGE_BUCKET_NAME = 'zappa-static'\n\nAWS_S3_CUSTOM_DOMAIN = '%s.s3.amazonaws.com' % AWS_STORAGE_BUCKET_NAME\n\nSTATIC_URL =  https://%s/  % AWS_S3_CUSTOM_DOMAIN\n\nSTATICFILES_STORAGE = 'storages.backends.s3boto.S3BotoStorage'", 
            "title": "Configure Django-Storages in settings.py"
        }, 
        {
            "location": "/walk_static/#push-your-static-files-to-the-cloud", 
            "text": "The funny thing about zappa is that generally you have a working local environment and a working lambda environment.  In theory either location can push the static files to the cloud.    Using your local environment:  python manage.py collectstatic --noinput  Or to instruct your zappa-powered AWS lambda environment to do it for you:  zappa manage dev  collectstatic --noinput", 
            "title": "Push your static files to the cloud"
        }, 
        {
            "location": "/walk_static/#test-with-the-admin", 
            "text": "Once you have pushed your static files to S3, you can visit the admin site for your Django project to test if it worked.  Appending /admin/ to your zappa project you can now browse to the admin site and watch the css being loaded just fine.", 
            "title": "Test with the admin"
        }, 
        {
            "location": "/walk_static/#next-steps", 
            "text": "Well great, now you have a working Django site that processes views and can serve static files.  But you can't login because there is no database.  Continue through the walkthroughs to complete a fully functional website.", 
            "title": "Next Steps"
        }, 
        {
            "location": "/walk_static/#additional-http-settings", 
            "text": "As mentioned above you probably want to ensure a valid CORS policy is in place for anything resembling production.  In addition there are many default HTTP headers that can be served with your static files to ensure proper caching and so forth.  The example format in your settings.py file is:      AWS_HEADERS = {  \n        'Expires': 'Thu, 31 Dec 2099 20:00:00 GMT',\n        'Cache-Control': 'max-age=94608000',\n    }", 
            "title": "Additional HTTP Settings"
        }, 
        {
            "location": "/walk_static/#helpful-links", 
            "text": "These two articles were extremely helpful when writing this page:   https://www.caktusgroup.com/blog/2014/11/10/Using-Amazon-S3-to-store-your-Django-sites-static-and-media-files/  http://django-storages.readthedocs.io/en/latest/backends/amazon-S3.html", 
            "title": "Helpful Links"
        }, 
        {
            "location": "/walk_database/", 
            "text": "Using a Database\n\n\nThis walkthough documents the steps necessary to connect your application to a hosted database.\n\n\nPrerequisites\n\n\nThis walkthough requires the (Core Django Setup)[walk_core.md] to be completed.  Also, it is important \nto have your network setup properly so check out (Adventures in Networking)[aws_network.md].  \n\n\nWe will assume you have chosen the VPC pattern: \"VPC with a Public subnet and Private subnet\"\nBut basically you will need the private subnet or subnets which can access the database.\n\n\nOptions for Databases\n\n\nUse AWS RDS\n\n\nThis is probably the easiest to get up and running.  AWS takes care of the messy details of managing the host and provides database-as-a-service (if that's a real thing).  In addition, AWS RDS supports mySQL and PostGreSQL, both which are highly compatible with Django.  \n\n\nHost Your Own\n\n\nOf course you can be running any type of database on an EC2 instance of your choosing.  Usually an EC2 instance will be associated with one subnet, but it is possible to have multiple IP addresses in different subnets for redundancy.\n\n\nUse another DB Service\n\n\nThere as some other database services such as DynamoDB.  Depending on the capabilities of the service, you may or may need the subnet information.  \n\n\nCreate your RDS Database\n\n\nWe'll just focus on the RDS case for this walkthough.  In fact we'll go through the walkthough using PostGreSQL.\n\n\nSo zip on over to (Creating an RDS Database)[aws_database.md] and set up one.  You should record some key information we'll need here:\n\n\n\n\nThe subnets (there should be at least two) in which we can access the database\n\n\nThe endpoint (hostname) of the database and the port\n\n\nThe username and password for the root user\n\n\n\n\nNote that at this point you don't yet have a database installed on your RDS instance.  So let's just pick a name we will use for the walkthough.  \n\n\nHere is our sample data:\n\n\n\n\n\n\n\n\nParameter\n\n\nSample value\n\n\n\n\n\n\n\n\n\n\nsubnets\n\n\nsubnet-f3446aba, subnet-c5b8c79e\n\n\n\n\n\n\nendpoint\n\n\nzappa-db.crt239fsjdlk.us-east-1.rds.amazonaws.com\n\n\n\n\n\n\ndb username\n\n\nadministrator\n\n\n\n\n\n\ndb password\n\n\nthis_is_not_a_good_password\n\n\n\n\n\n\ndb name\n\n\nzappadbname\n\n\n\n\n\n\n\n\nSetup your Configuration\n\n\nEdit requirements\n\n\nNote on PostGreSQL: because the psycopg2 library often involves compiling the library, I would suggest using the \nDocker version of zappa\n to ensure you have isolation of environments and you don't mess up your local system.\n\n\nAdd this to your requirements.txt \n\npsycopg2\n\n\n\nand then\n\n\npip install -r requirements\n\n\n\n\nDjango Settings\n\n\nAdd the above settings to your settings.py\n\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql_psycopg2',\n        'NAME': 'zappadbname',\n        'USER': 'administrator',\n        'PASSWORD': 'this_is_not_a_good_password',\n        'HOST': 'zappa-db.crt239fsjdlk.us-east-1.rds.amazonaws.com',\n        'PORT': '5432',\n    }\n\n}\n\n\n\n\nZappa Settings\n\n\n{\n    \ndev\n: {\n        \ndjango_settings\n: \nfrankie.settings\n, \n        \ns3_bucket\n: \nzappatest-code\n,\n        \naws_region\n: \nus-east-1\n,\n        \nvpc_config\n : {\n            \nSubnetIds\n: [ \nsubnet-f3446aba\n,\nsubnet-c5b8c79e\n ], // use the private subnet\n            \nSecurityGroupIds\n: [ \nsg-9a9a1dfc\n ]\n        }\n    }\n}\n\n\n\n\nCreate your Database\n\n\nOk, easy so far?  Yes!  All we had to do up to this point was carefully click a mouse in the AWS console and \nedit some text files.  Well fun time is over - now we run into some bootstrapping problems.  Fortunately, we only have to do this once each time we need a new database.\n\n\nTurns out that when AWS creates a PostGreSQL RDS instance for you, it doesn't create a database.  So you have to do it yourself.  There are many options, but two methods could be:\n\n\n\n\nUse a db tool on your local machine via a bastion host \n\n\nWrite some code to setup the database using zappa\n\n\n\n\nOption 1 is easy if you have the db tool and the bastion host setup.  But let's explore how to do option two.\n\n\nWell, there is no easy way to get this done but here is a possible option: create a management command that can be run in the zappa environment.  \n\n\nCreate a management command in your Django Project\n\n\nFollow these steps to create a management command environment (make sure your virtualenv is fired up)\n\n\ncd frankie\npython manage.py startapp axe\ncd axe\nmkdir management\ncd management\ntouch __init.py__\nmkdir commands\ncd commands\ntouch __init.py__\n\n\n\n\nThen create a file called \ncreate_db.py\n\n\nfrom psycopg2 import connect\nfrom psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT\nfrom django.core.management.base import BaseCommand, CommandError\nfrom django.conf import settings\n\nclass Command(BaseCommand):\n    help = 'Creates the initial database'\n\n    def handle(self, *args, **options):\n        self.stdout.write(self.style.SUCCESS('Starting db creation'))\n\n        dbname = settings.DATABASES['default']['NAME']\n        user = settings.DATABASES['default']['USER']\n        password = settings.DATABASES['default']['PASSWORD']\n        host = settings.DATABASES['default']['HOST']\n\n        con = None\n        con = connect(dbname='postgres', user=user, host = host, password=password)\n        dbname = dbname\n        con.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)\n        cur = con.cursor()\n        cur.execute('CREATE DATABASE ' + dbname)\n        cur.close()\n        con.close()\n\n        self.stdout.write(self.style.SUCCESS('All Done'))\n\n\n\n\nRun the management command\n\n\nzappa dev manage create_db\n\n\n\n\nInit the Database\n\n\nCreate your Django superuser\n\n\nAgain, a bit of a pain in the ass\n\n\nTest and profit\n\n\n(http://marcelog.github.io/articles/aws_lambda_internet_vpc.html)\n\n\n[https://www.isc.upenn.edu/accessing-mysql-databases-aws-python-lambda-function]", 
            "title": "Using a Database"
        }, 
        {
            "location": "/walk_database/#using-a-database", 
            "text": "This walkthough documents the steps necessary to connect your application to a hosted database.", 
            "title": "Using a Database"
        }, 
        {
            "location": "/walk_database/#prerequisites", 
            "text": "This walkthough requires the (Core Django Setup)[walk_core.md] to be completed.  Also, it is important \nto have your network setup properly so check out (Adventures in Networking)[aws_network.md].    We will assume you have chosen the VPC pattern: \"VPC with a Public subnet and Private subnet\"\nBut basically you will need the private subnet or subnets which can access the database.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/walk_database/#options-for-databases", 
            "text": "", 
            "title": "Options for Databases"
        }, 
        {
            "location": "/walk_database/#use-aws-rds", 
            "text": "This is probably the easiest to get up and running.  AWS takes care of the messy details of managing the host and provides database-as-a-service (if that's a real thing).  In addition, AWS RDS supports mySQL and PostGreSQL, both which are highly compatible with Django.", 
            "title": "Use AWS RDS"
        }, 
        {
            "location": "/walk_database/#host-your-own", 
            "text": "Of course you can be running any type of database on an EC2 instance of your choosing.  Usually an EC2 instance will be associated with one subnet, but it is possible to have multiple IP addresses in different subnets for redundancy.", 
            "title": "Host Your Own"
        }, 
        {
            "location": "/walk_database/#use-another-db-service", 
            "text": "There as some other database services such as DynamoDB.  Depending on the capabilities of the service, you may or may need the subnet information.", 
            "title": "Use another DB Service"
        }, 
        {
            "location": "/walk_database/#create-your-rds-database", 
            "text": "We'll just focus on the RDS case for this walkthough.  In fact we'll go through the walkthough using PostGreSQL.  So zip on over to (Creating an RDS Database)[aws_database.md] and set up one.  You should record some key information we'll need here:   The subnets (there should be at least two) in which we can access the database  The endpoint (hostname) of the database and the port  The username and password for the root user   Note that at this point you don't yet have a database installed on your RDS instance.  So let's just pick a name we will use for the walkthough.    Here is our sample data:     Parameter  Sample value      subnets  subnet-f3446aba, subnet-c5b8c79e    endpoint  zappa-db.crt239fsjdlk.us-east-1.rds.amazonaws.com    db username  administrator    db password  this_is_not_a_good_password    db name  zappadbname", 
            "title": "Create your RDS Database"
        }, 
        {
            "location": "/walk_database/#setup-your-configuration", 
            "text": "", 
            "title": "Setup your Configuration"
        }, 
        {
            "location": "/walk_database/#edit-requirements", 
            "text": "Note on PostGreSQL: because the psycopg2 library often involves compiling the library, I would suggest using the  Docker version of zappa  to ensure you have isolation of environments and you don't mess up your local system.  Add this to your requirements.txt  psycopg2  and then  pip install -r requirements", 
            "title": "Edit requirements"
        }, 
        {
            "location": "/walk_database/#django-settings", 
            "text": "Add the above settings to your settings.py  DATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql_psycopg2',\n        'NAME': 'zappadbname',\n        'USER': 'administrator',\n        'PASSWORD': 'this_is_not_a_good_password',\n        'HOST': 'zappa-db.crt239fsjdlk.us-east-1.rds.amazonaws.com',\n        'PORT': '5432',\n    }\n\n}", 
            "title": "Django Settings"
        }, 
        {
            "location": "/walk_database/#zappa-settings", 
            "text": "{\n     dev : {\n         django_settings :  frankie.settings , \n         s3_bucket :  zappatest-code ,\n         aws_region :  us-east-1 ,\n         vpc_config  : {\n             SubnetIds : [  subnet-f3446aba , subnet-c5b8c79e  ], // use the private subnet\n             SecurityGroupIds : [  sg-9a9a1dfc  ]\n        }\n    }\n}", 
            "title": "Zappa Settings"
        }, 
        {
            "location": "/walk_database/#create-your-database", 
            "text": "Ok, easy so far?  Yes!  All we had to do up to this point was carefully click a mouse in the AWS console and \nedit some text files.  Well fun time is over - now we run into some bootstrapping problems.  Fortunately, we only have to do this once each time we need a new database.  Turns out that when AWS creates a PostGreSQL RDS instance for you, it doesn't create a database.  So you have to do it yourself.  There are many options, but two methods could be:   Use a db tool on your local machine via a bastion host   Write some code to setup the database using zappa   Option 1 is easy if you have the db tool and the bastion host setup.  But let's explore how to do option two.  Well, there is no easy way to get this done but here is a possible option: create a management command that can be run in the zappa environment.", 
            "title": "Create your Database"
        }, 
        {
            "location": "/walk_database/#create-a-management-command-in-your-django-project", 
            "text": "Follow these steps to create a management command environment (make sure your virtualenv is fired up)  cd frankie\npython manage.py startapp axe\ncd axe\nmkdir management\ncd management\ntouch __init.py__\nmkdir commands\ncd commands\ntouch __init.py__  Then create a file called  create_db.py  from psycopg2 import connect\nfrom psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT\nfrom django.core.management.base import BaseCommand, CommandError\nfrom django.conf import settings\n\nclass Command(BaseCommand):\n    help = 'Creates the initial database'\n\n    def handle(self, *args, **options):\n        self.stdout.write(self.style.SUCCESS('Starting db creation'))\n\n        dbname = settings.DATABASES['default']['NAME']\n        user = settings.DATABASES['default']['USER']\n        password = settings.DATABASES['default']['PASSWORD']\n        host = settings.DATABASES['default']['HOST']\n\n        con = None\n        con = connect(dbname='postgres', user=user, host = host, password=password)\n        dbname = dbname\n        con.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)\n        cur = con.cursor()\n        cur.execute('CREATE DATABASE ' + dbname)\n        cur.close()\n        con.close()\n\n        self.stdout.write(self.style.SUCCESS('All Done'))", 
            "title": "Create a management command in your Django Project"
        }, 
        {
            "location": "/walk_database/#run-the-management-command", 
            "text": "zappa dev manage create_db", 
            "title": "Run the management command"
        }, 
        {
            "location": "/walk_database/#init-the-database", 
            "text": "", 
            "title": "Init the Database"
        }, 
        {
            "location": "/walk_database/#create-your-django-superuser", 
            "text": "Again, a bit of a pain in the ass", 
            "title": "Create your Django superuser"
        }, 
        {
            "location": "/walk_database/#test-and-profit", 
            "text": "(http://marcelog.github.io/articles/aws_lambda_internet_vpc.html)  [https://www.isc.upenn.edu/accessing-mysql-databases-aws-python-lambda-function]", 
            "title": "Test and profit"
        }, 
        {
            "location": "/walk_cdn/", 
            "text": "", 
            "title": "You need a CDN"
        }, 
        {
            "location": "/walk_https/", 
            "text": "", 
            "title": "Secure HTTPS"
        }, 
        {
            "location": "/walk_media/", 
            "text": "Managing Media files (or any other file)\n\n\nSo we're talking mostly about getting stuff in/out of S3\n\n\nBaseline setup\n\n\nhttp://serverfault.com/questions/578571/accessing-amazon-s3-from-a-private-vpc-subnet\nhttp://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-endpoints-s3.html?shortFooter=true\nhttp://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-endpoints.html#vpc-endpoints-limitations", 
            "title": "Wrangling Media Files"
        }, 
        {
            "location": "/walk_media/#managing-media-files-or-any-other-file", 
            "text": "So we're talking mostly about getting stuff in/out of S3  Baseline setup  http://serverfault.com/questions/578571/accessing-amazon-s3-from-a-private-vpc-subnet\nhttp://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-endpoints-s3.html?shortFooter=true\nhttp://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-endpoints.html#vpc-endpoints-limitations", 
            "title": "Managing Media files (or any other file)"
        }, 
        {
            "location": "/walk_scheduling/", 
            "text": "", 
            "title": "Tasks and Events"
        }, 
        {
            "location": "/walk_debug/", 
            "text": "", 
            "title": "Debugging"
        }, 
        {
            "location": "/aws_credentials/", 
            "text": "Managing AWS Credentials\n\n\nGetting Started with AWS and Zappa\n\n\nDetails in this section are light because this information is documented well elsewhere on the web.\n\n\n\n\nCreate AWS Account if you haven't already\n\n\nCreate an S3 bucket.\n\n   For purposes of this walkthrough I have used the bucket name of \nzappatest-code\n in the 'US Standard' region.  This bucket will be used by zappa as a mechanism to upload your project into the lambda environment.  Thus it will generally be empty except during the brief time you are deploying the project.\n\n\nCreate an IAM User with API keys\n   Easier said than done.  The quick and easy way of doing this is to create a user with a policy that allows a very broad set of permissions.  However, this is not great from a security perspective. There is an \nongoing discussion\n about the exact set of permissions needed.\n\n\n\n\nNow we need to allow scripts and local programs to get the credentials created above.  You have some options for this:\n\n\nSetup Local Account Credentials\n\n\n\n\n\n\nSet \nenvironment variables\n\n\nThis is very easy but must be done for each bash console you are using.\n\n\nexport AWS_ACCESS_KEY_ID=\nyour key here\n\nexport AWS_SECRET_ACCESS_KEY=\nyour secret access key here\n\n\n\n\n\n\n\n\n\nCreate a local credentials file (\n~/.aws/credentials\n on Linux, or OS X)\n\n\nProbably a better long term solution since you can store multiple \n sets of keys for different environments using profiles.  In addition, you can provide multiple profiles that provides some isolation between AWS accounts and/or roles.  The alternate profile example shown below is called 'zappa'\n\n\n[default]\naws_access_key_id = your_access_key_id\naws_secret_access_key = your_secret_access_key\n\n[zappa]\naws_access_key_id = your_access_key_id_specific_to_zappa\naws_secret_access_key = your_secret_access_key_specific_to_zappa\n\n\n\n\nSince you have multiple profiles, it is recommended that you use an environment variable to distinguish which profile is desired to be active.  Shown here is an example of using the 'zappa' profile:\n\n\nexport AWS_PROFILE=zappa\n\n\n\n\n\n\n\n\nUseful links for Windows or more information:\n\n\n\n\nhttp://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/setup-credentials.html\n\n\nhttp://boto3.readthedocs.io/en/latest/guide/configuration.html#configuring-credentials", 
            "title": "Managing Credentials"
        }, 
        {
            "location": "/aws_credentials/#managing-aws-credentials", 
            "text": "", 
            "title": "Managing AWS Credentials"
        }, 
        {
            "location": "/aws_credentials/#getting-started-with-aws-and-zappa", 
            "text": "Details in this section are light because this information is documented well elsewhere on the web.   Create AWS Account if you haven't already  Create an S3 bucket. \n   For purposes of this walkthrough I have used the bucket name of  zappatest-code  in the 'US Standard' region.  This bucket will be used by zappa as a mechanism to upload your project into the lambda environment.  Thus it will generally be empty except during the brief time you are deploying the project.  Create an IAM User with API keys\n   Easier said than done.  The quick and easy way of doing this is to create a user with a policy that allows a very broad set of permissions.  However, this is not great from a security perspective. There is an  ongoing discussion  about the exact set of permissions needed.   Now we need to allow scripts and local programs to get the credentials created above.  You have some options for this:", 
            "title": "Getting Started with AWS and Zappa"
        }, 
        {
            "location": "/aws_credentials/#setup-local-account-credentials", 
            "text": "Set  environment variables  This is very easy but must be done for each bash console you are using.  export AWS_ACCESS_KEY_ID= your key here \nexport AWS_SECRET_ACCESS_KEY= your secret access key here     Create a local credentials file ( ~/.aws/credentials  on Linux, or OS X)  Probably a better long term solution since you can store multiple \n sets of keys for different environments using profiles.  In addition, you can provide multiple profiles that provides some isolation between AWS accounts and/or roles.  The alternate profile example shown below is called 'zappa'  [default]\naws_access_key_id = your_access_key_id\naws_secret_access_key = your_secret_access_key\n\n[zappa]\naws_access_key_id = your_access_key_id_specific_to_zappa\naws_secret_access_key = your_secret_access_key_specific_to_zappa  Since you have multiple profiles, it is recommended that you use an environment variable to distinguish which profile is desired to be active.  Shown here is an example of using the 'zappa' profile:  export AWS_PROFILE=zappa", 
            "title": "Setup Local Account Credentials"
        }, 
        {
            "location": "/aws_credentials/#useful-links-for-windows-or-more-information", 
            "text": "http://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/setup-credentials.html  http://boto3.readthedocs.io/en/latest/guide/configuration.html#configuring-credentials", 
            "title": "Useful links for Windows or more information:"
        }, 
        {
            "location": "/aws_network/", 
            "text": "Adventures in Networking\n\n\nPresumably, since you've read this far, you're interested in more than a simple Django powered API serving static images.  You probably want something that is more interactive with users and have have advanced capabilities.  So this will require interacting with additional AWS services like RDS or DynamoDB for database services, SNS or SQS for task processing, and many more...\n\n\nWell, there is an important aspect about interacting with additional AWS services.  With pure AWS lambda, we have a fairly low attack surface, but when we introduce additional interactions over the network, we must consider information security risks and our network architecture.\n\n\nA simple, but naive approach\n\n\nA simple approach would be to create an AWS RDS instance that is open to the Internet and have your lambda Django project login directly.  While this may work, this approach is fraught with peril.  Numerous vulnerabilities could exist and credentials could be discovered by brute force.  Even without gaining access to your RDS, it is trivial to launch a denial-of-service attack to ensure your Django project has no database services.\n\n\nBasically, do not do this.\n\n\nThat's why Amazon has VPC\n\n\nIntroducing AWS Virtual Private Cloud (VPC).  This service provides a way of segmenting Internet traffic from your other AWS services.  This feature is incredibly valuable to securing our project.  So that bad guys have the smallest attack surface possible.  It's easy to setup a VPC - there are many webpages that will assist you.  But basically you pick an IP range and let it fly.\n\n\nOnce a VPC is established, you can then subdivide the VPC into subnets.  Which are little non-overlapping IP chunks of the overall VPC.  Like dividing a pie into slices.  \n\n\nIt is important to realize that you have almost entire control of your IP space when you define your VPC and associated subnets.  You are creating a Software Defined Network (SDN) and you have a lot of leeway.  With this freedom comes choices and important considerations on how you design your network.\n\n\nThe Essential VPC and Subnet Configuration\n\n\nHere is the absolute minimum you must have to have a working Django site within a VPC:\n\n\n\n\nA VPC\n\n\nA subnet within the VPC\n\n\nA security group\n\n\nYour zappa project configured to use the subnet and security group\n\n\n\n\nThere are no need for routes, NAT gateways, Internet gateways, or even allowing inbound rules on the security group.  You will probably need many of these services eventually for a robust and full-featured application, but for illustration purposes now, we will keep it simple.\n\n\nYou may be asking yourself how will traffic from the Internet reach the lambda function. Well essentially the magic is in the API Gateway that zappa creates on deployment.  From the \nAPI Gateway FAQ\n:\n\n\n\n\nAmazon API Gateway endpoints are always public to the Internet. Proxy requests to backend operations also need to be publicly accessible on the Internet. However, you can generate a client-side SSL certificate in Amazon API Gateway to verify that requests to your backend systems were sent by API Gateway using the public key of the certificate.\n\n\n\n\nSo API Gateways act as an 'always-on' Internet facing service that sends the HTTP requests directly to the Zappa Lambda functions - even if the Lambda functions are in a top-secret lockbox.  Note that in the above VPC setup the Lambda function is completely isolated from direct access to the Internet.  Thus the Lambda functions can't make outbound connections to anything: other servers, databases, S3, etc.\n\n\nLet's face it, there's no real point to going through the effort of doing this if the Lambda functions are really this isolated.  \nBut\n the reason this information is important is because in order to leverage other AWS resources, the VPC lays the foundation to do this securely.\n\n\nExtending the VPC\n\n\nTo re-iterate: we don't need a VPC network to make the Zappa Lambda-powered Django site visible on the Internet.  We need to extend the VPC so that we can add more AWS services like:\n\n\n\n\nAdding an RDS database that is only accessible from our Lambda functions\n\n\nAdding an S3 bucket \n\n\nAllowing Lambda functions to communicate to traditional EC2 instances for long running processes\n\n\nAllowing the Lambda functions to access the Internet to hit an external API\n\n\nAbility to interact with SQS and/or SNS\n\n\n\n\nThe important thing is that we can enable all these scenarios in a secure manner.  There are too many scenarios to go into detail here, so we will provide some guidelines.\n\n\nNext we learn about the common patterns of VPC usage and try to identify usage options.\n\n\nOne warning before we go on with VPC and Lambda:  When Lambda functions fire, they must be assigned an IP address temporarily.  If you have a lot of Lambda functions firing, then you must have a lot of IP addresses available.  You can learn more \nhere\n.\n\n\nVPC Patterns\n\n\nWhile the actual VPC itself is very straightforward, the combination of subnets within the VPC can take many forms.  Additionally, you must consider how the subnets will communicate among themselves as well as how  they communicate with outside networks. For a more comprehensive list of options and other valuable information about VPCs, see this link: \nhttps://aws.amazon.com/answers/networking/aws-single-vpc-design/\n\n\nThe options are summarized here:\n\n\nVPC with a single Internet-Accessible subnet\n\n\nThis pattern places your lambda functions, your RDS, and additional SNS/SQS services in a single subnet that is Internet accessible in your VPC.  In theory you could configure your security groups to ensure only lambda functions can hit your RDS.  \n\n\nOne advantage of this setup is that you can setup your local machine to connect to your RDS without a \nbastion host\n.  Just restrict access based on IP.  \n\n\nImportant note - you will want to ensure careful inbound IP restrictions.  While it's great that you can connect to RDS with your SQL desktop client, you should setup a \nbastion host\n.\n\n\nThis scenario is good for straightforward setups with a little work\n\n\nVPC with a Public subnet and Private subnet\n\n\nArguably the most flexible and future-proof of all web application setups.  You have two subnets: one public and one private.  Your RDS and lambda functions reside in the private subnet, far away from bad guys, but also far away from your local machine.  In order to access the database from your system you will need a \nbastion host\n in the public subnet.  \n\n\nAnother advantage of this setup is that if you ever want to add additional EC2-based services that need to interact with the Internet you can do this very easily without compromising security.  \n\n\nGenerally this setup will require networking knowledge to setup the Internet gateway, bastion host, and NAT Gateway.\n\n\nThe upshot is this configuration is the most secure and most flexible for your growth but will be complex from a network standpoint\n\n\nOn-Premises and Internet-Accessible VPC\n\n\nSame as the last configuration, but if you have an internal corporate network to connect, you can easily establish a connection to the private subnet without compromising security.\n\n\nIf you thought the last setup was complex, you better know what you are doing from a network standpoint.\n\n\nA good solution if you need to connect an internal corporate network\n\n\nVPC with an Internal-Only subnet\n\n\nObviously a very special case of creating a Django app for internal use only with no desire to have it accessible by the Internet.\n\n\nThis is actually most secure.  Since you can access any of the resources from your desktop on the internal network.  Not bad for the paranoid or security conscious devops team.\n\n\nUseful for the simple environment if you have an existing secure network\n\n\nSubdividing the VPC\n\n\nOnce you get a VPC selected you must create subnets within the VPC.  When defining a subnet, you just have to pick a non-overlapping segment of the ip range.  So if you have VPC that spans IP address 10.5.0.1 to 10.5.0.254, then you pick contiguous segments within this range.\n\n\nExamples for Walkthroughs\n\n\nFor the purposes of walkthroughs, we will leverage a simple VPC with a single subnet.  A single subnet will generally be enough to guide readers through the scenarios.\n\n\nWe have a VPC:\n\n\n\n\nid: vpc-9a9a1dfc\n\n\ncidr: 10.6.0.0/16\n\n\n\n\nWith subnet:\n\n\n\n\nid: subnet-f3446aba\n\n\ncidr: 10.6.1.0/24\n\n\n\n\nAnd security group:\n\n\n\n\nid: sg-13a5736f\n\n\ninbound rules: none\n\n\noutbound rules: all traffic\n\n\n\n\n\n\nTODO: Show example zappa configuration here\n\n\n\n\nNote on Redundancy\n\n\nWhile these examples are all using a single subnet for clarity, in production you will want to create multiple subnets within the VPC all with different availability zones.  This ensures if there is a failure within a single subnet, there are alternate paths.  \n\n\nThe general approach is to associate the Lambda functions with multiple subnets and the AWS resources with the same multiple subnets (e.g. RDS).", 
            "title": "Adventures in Networking"
        }, 
        {
            "location": "/aws_network/#adventures-in-networking", 
            "text": "Presumably, since you've read this far, you're interested in more than a simple Django powered API serving static images.  You probably want something that is more interactive with users and have have advanced capabilities.  So this will require interacting with additional AWS services like RDS or DynamoDB for database services, SNS or SQS for task processing, and many more...  Well, there is an important aspect about interacting with additional AWS services.  With pure AWS lambda, we have a fairly low attack surface, but when we introduce additional interactions over the network, we must consider information security risks and our network architecture.", 
            "title": "Adventures in Networking"
        }, 
        {
            "location": "/aws_network/#a-simple-but-naive-approach", 
            "text": "A simple approach would be to create an AWS RDS instance that is open to the Internet and have your lambda Django project login directly.  While this may work, this approach is fraught with peril.  Numerous vulnerabilities could exist and credentials could be discovered by brute force.  Even without gaining access to your RDS, it is trivial to launch a denial-of-service attack to ensure your Django project has no database services.  Basically, do not do this.", 
            "title": "A simple, but naive approach"
        }, 
        {
            "location": "/aws_network/#thats-why-amazon-has-vpc", 
            "text": "Introducing AWS Virtual Private Cloud (VPC).  This service provides a way of segmenting Internet traffic from your other AWS services.  This feature is incredibly valuable to securing our project.  So that bad guys have the smallest attack surface possible.  It's easy to setup a VPC - there are many webpages that will assist you.  But basically you pick an IP range and let it fly.  Once a VPC is established, you can then subdivide the VPC into subnets.  Which are little non-overlapping IP chunks of the overall VPC.  Like dividing a pie into slices.    It is important to realize that you have almost entire control of your IP space when you define your VPC and associated subnets.  You are creating a Software Defined Network (SDN) and you have a lot of leeway.  With this freedom comes choices and important considerations on how you design your network.", 
            "title": "That's why Amazon has VPC"
        }, 
        {
            "location": "/aws_network/#the-essential-vpc-and-subnet-configuration", 
            "text": "Here is the absolute minimum you must have to have a working Django site within a VPC:   A VPC  A subnet within the VPC  A security group  Your zappa project configured to use the subnet and security group   There are no need for routes, NAT gateways, Internet gateways, or even allowing inbound rules on the security group.  You will probably need many of these services eventually for a robust and full-featured application, but for illustration purposes now, we will keep it simple.  You may be asking yourself how will traffic from the Internet reach the lambda function. Well essentially the magic is in the API Gateway that zappa creates on deployment.  From the  API Gateway FAQ :   Amazon API Gateway endpoints are always public to the Internet. Proxy requests to backend operations also need to be publicly accessible on the Internet. However, you can generate a client-side SSL certificate in Amazon API Gateway to verify that requests to your backend systems were sent by API Gateway using the public key of the certificate.   So API Gateways act as an 'always-on' Internet facing service that sends the HTTP requests directly to the Zappa Lambda functions - even if the Lambda functions are in a top-secret lockbox.  Note that in the above VPC setup the Lambda function is completely isolated from direct access to the Internet.  Thus the Lambda functions can't make outbound connections to anything: other servers, databases, S3, etc.  Let's face it, there's no real point to going through the effort of doing this if the Lambda functions are really this isolated.   But  the reason this information is important is because in order to leverage other AWS resources, the VPC lays the foundation to do this securely.", 
            "title": "The Essential VPC and Subnet Configuration"
        }, 
        {
            "location": "/aws_network/#extending-the-vpc", 
            "text": "To re-iterate: we don't need a VPC network to make the Zappa Lambda-powered Django site visible on the Internet.  We need to extend the VPC so that we can add more AWS services like:   Adding an RDS database that is only accessible from our Lambda functions  Adding an S3 bucket   Allowing Lambda functions to communicate to traditional EC2 instances for long running processes  Allowing the Lambda functions to access the Internet to hit an external API  Ability to interact with SQS and/or SNS   The important thing is that we can enable all these scenarios in a secure manner.  There are too many scenarios to go into detail here, so we will provide some guidelines.  Next we learn about the common patterns of VPC usage and try to identify usage options.  One warning before we go on with VPC and Lambda:  When Lambda functions fire, they must be assigned an IP address temporarily.  If you have a lot of Lambda functions firing, then you must have a lot of IP addresses available.  You can learn more  here .", 
            "title": "Extending the VPC"
        }, 
        {
            "location": "/aws_network/#vpc-patterns", 
            "text": "While the actual VPC itself is very straightforward, the combination of subnets within the VPC can take many forms.  Additionally, you must consider how the subnets will communicate among themselves as well as how  they communicate with outside networks. For a more comprehensive list of options and other valuable information about VPCs, see this link:  https://aws.amazon.com/answers/networking/aws-single-vpc-design/  The options are summarized here:", 
            "title": "VPC Patterns"
        }, 
        {
            "location": "/aws_network/#vpc-with-a-single-internet-accessible-subnet", 
            "text": "This pattern places your lambda functions, your RDS, and additional SNS/SQS services in a single subnet that is Internet accessible in your VPC.  In theory you could configure your security groups to ensure only lambda functions can hit your RDS.    One advantage of this setup is that you can setup your local machine to connect to your RDS without a  bastion host .  Just restrict access based on IP.    Important note - you will want to ensure careful inbound IP restrictions.  While it's great that you can connect to RDS with your SQL desktop client, you should setup a  bastion host .  This scenario is good for straightforward setups with a little work", 
            "title": "VPC with a single Internet-Accessible subnet"
        }, 
        {
            "location": "/aws_network/#vpc-with-a-public-subnet-and-private-subnet", 
            "text": "Arguably the most flexible and future-proof of all web application setups.  You have two subnets: one public and one private.  Your RDS and lambda functions reside in the private subnet, far away from bad guys, but also far away from your local machine.  In order to access the database from your system you will need a  bastion host  in the public subnet.    Another advantage of this setup is that if you ever want to add additional EC2-based services that need to interact with the Internet you can do this very easily without compromising security.    Generally this setup will require networking knowledge to setup the Internet gateway, bastion host, and NAT Gateway.  The upshot is this configuration is the most secure and most flexible for your growth but will be complex from a network standpoint", 
            "title": "VPC with a Public subnet and Private subnet"
        }, 
        {
            "location": "/aws_network/#on-premises-and-internet-accessible-vpc", 
            "text": "Same as the last configuration, but if you have an internal corporate network to connect, you can easily establish a connection to the private subnet without compromising security.  If you thought the last setup was complex, you better know what you are doing from a network standpoint.  A good solution if you need to connect an internal corporate network", 
            "title": "On-Premises and Internet-Accessible VPC"
        }, 
        {
            "location": "/aws_network/#vpc-with-an-internal-only-subnet", 
            "text": "Obviously a very special case of creating a Django app for internal use only with no desire to have it accessible by the Internet.  This is actually most secure.  Since you can access any of the resources from your desktop on the internal network.  Not bad for the paranoid or security conscious devops team.  Useful for the simple environment if you have an existing secure network", 
            "title": "VPC with an Internal-Only subnet"
        }, 
        {
            "location": "/aws_network/#subdividing-the-vpc", 
            "text": "Once you get a VPC selected you must create subnets within the VPC.  When defining a subnet, you just have to pick a non-overlapping segment of the ip range.  So if you have VPC that spans IP address 10.5.0.1 to 10.5.0.254, then you pick contiguous segments within this range.", 
            "title": "Subdividing the VPC"
        }, 
        {
            "location": "/aws_network/#examples-for-walkthroughs", 
            "text": "For the purposes of walkthroughs, we will leverage a simple VPC with a single subnet.  A single subnet will generally be enough to guide readers through the scenarios.  We have a VPC:   id: vpc-9a9a1dfc  cidr: 10.6.0.0/16   With subnet:   id: subnet-f3446aba  cidr: 10.6.1.0/24   And security group:   id: sg-13a5736f  inbound rules: none  outbound rules: all traffic    TODO: Show example zappa configuration here", 
            "title": "Examples for Walkthroughs"
        }, 
        {
            "location": "/aws_network/#note-on-redundancy", 
            "text": "While these examples are all using a single subnet for clarity, in production you will want to create multiple subnets within the VPC all with different availability zones.  This ensures if there is a failure within a single subnet, there are alternate paths.    The general approach is to associate the Lambda functions with multiple subnets and the AWS resources with the same multiple subnets (e.g. RDS).", 
            "title": "Note on Redundancy"
        }, 
        {
            "location": "/aws_database/", 
            "text": "Creating an RDS Database\n\n\ninstructions on how to create a PostGreSQL database here", 
            "title": "Creating an RDS Database"
        }, 
        {
            "location": "/aws_database/#creating-an-rds-database", 
            "text": "instructions on how to create a PostGreSQL database here", 
            "title": "Creating an RDS Database"
        }, 
        {
            "location": "/additional/", 
            "text": "Additional Resources\n\n\nThis site powered by \nmkdocs\n and powered by github. \n\n\nSource documents are here: \nhttps://github.com/edgarroman/zappa-django-guide", 
            "title": "Additional"
        }, 
        {
            "location": "/additional/#additional-resources", 
            "text": "This site powered by  mkdocs  and powered by github.   Source documents are here:  https://github.com/edgarroman/zappa-django-guide", 
            "title": "Additional Resources"
        }
    ]
}